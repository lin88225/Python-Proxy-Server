0:00-0:45 | Intro & Design: "This is my CSU33032 Project 1. Iâ€™ve implemented a multi-threaded Web Proxy in Python using raw sockets to avoid high-level library overuse. The proxy listens on Port 4000."
+1

0:45-1:30 | Request Display: "Notice the console logs. As I navigate in Chrome, the proxy displays every HTTP and HTTPS request in real-time on the management console." (Pause to let the logs scroll).


1:30-2:15 | Dynamic Blocking: "I will now block 'example.com' via the console. When I try to visit it, the proxy intercepts the request and sends a 403 Forbidden response back to the browser." (Show the blocked page in browser).


2:15-3:15 | Caching & RTT Proof: "To prove efficiency, look at the timing data. The first visit to an HTTP site takes 180ms. On the second visit, the proxy serves a local cached copy in under 2ms." (Highlight the RTT difference in the terminal).
+1


3:15-4:00 | Multi-threading: "Finally, the proxy uses the threading module to handle these dozens of background requests simultaneously, ensuring no single connection blocks the server."